---
title: Compiling binary executables
author: A.
published: February 22, 2024
tags: asm, c, zig
---

Almost all compiled languages generate binary executables via the following
pipeline:

<div style="text-align: center">
```
text -> AST -> IR -> machine code
```
</div>

Here *text* refers to code written in the programming language in question.
All examples in this article will use C with the [Zig][3] C compiler to
build binares for an `x86_64` Linux machine.

```c
> cat collatz.c
```
```c
int collatz(int n) {
    if (n % 2 == 0) {
        return n / 2;
    }
    return 3 * n + 1;
}
```
<div class=label>A simple C file declaring a [Collatz][7] function</div>

An AST is an *abstract syntax tree*: a data structure representing the parsed
text code.

```c
> zig cc -E -Xclang -ast-dump collatz.c | clean-up-by-hand
```
```c
\-FunctionDecl collatz "int (int)"
  |-ParmVarDecl used n "int"
  \-CompoundStmt
    |-IfStmt
    | |-BinaryOperator "int" "=="
    | | |-BinaryOperator "int" "%"
    | | | |-ImplicitCastExpr "int" <LValueToRValue>
    | | | | \-DeclRefExpr "int" lvalue ParmVar "n" "int"
    | | | \-IntegerLiteral "int" 2
    | | \-IntegerLiteral "int" 0
    | \-CompoundStmt
    |   \-ReturnStmt
    |     \-BinaryOperator "int" "/"
    |       |-ImplicitCastExpr "int" <LValueToRValue>
    |       | \-DeclRefExpr "int" lvalue ParmVar "n" "int"
    |       \-IntegerLiteral "int" 2
    \-ReturnStmt
      \-BinaryOperator "int" "+"
        |-BinaryOperator "int" "*"
        | |-IntegerLiteral "int" 3
        | \-ImplicitCastExpr "int" <LValueToRValue>
        |   \-DeclRefExpr "int" lvalue ParmVar "n" "int"
        \-IntegerLiteral "int" 1
```
<div class=label>A cleaned up AST from LLVM for our `collatz.c` file</div>

IR stands for *intermediate representation*: code designed to run on a basic abstract
machine. The IR step is mainly used to perform optimizations in a
simplified architecture agnostic environment.
Multiple IR stages might be involved in compilation, e.g. a compiler might have a
bespoke internal IR which is converted to a separate IR used by
a backend (such as [LLVM][1] or [QBE][2]).

```c
> cproc-qbe collatz.c > collatz.ssa
> cat collatz.ssa
```
```ts
export function w $collatz(w %.1) {
@start.1
	%.2 =l alloc4 4
	storew %.1, %.2
@body.2
	%.3 =w loadw %.2
	%.4 =w rem %.3, 2
	%.5 =w ceqw %.4, 0
	jnz %.5, @if_true.3, @if_false.4
@if_true.3
	%.6 =w loadw %.2
	%.7 =w div %.6, 2
	ret %.7
@if_false.4
	%.8 =w loadw %.2
	%.9 =w mul 3, %.8
	%.10 =w add %.9, 1
	ret %.10
}
```
<div class=label>The [QBE][2] IR generated by [cproc][6] for `collatz.c`</div>

Finally, *machine code* is a collection of binary data and CPU instructions
that might eventually be loaded into memory and run on a physical (or virtual) CPU.
A human readable *assembly language* version of the output from the
machine code step may also be generated.

```c
> qbe -o collatz.s collatz.ssa
> cat collatz.s
```
```ts
.text
.globl collatz
collatz:
	pushq %rbp
	movq %rsp, %rbp
	movl %edi, %eax
	movl $2, %esi
	movl %eax, %ecx
	cltd
	idivl %esi
	movl %ecx, %eax
	movl %edx, %ecx
	cmpl $0, %ecx
	jz .Lbb3
	imull $3, %eax, %eax
	addl $1, %eax
	jmp .Lbb4
.Lbb3:
	movl $2, %ecx
	cltd
	idivl %ecx
.Lbb4:
	leave
	ret
.type collatz, @function
.size collatz, .-collatz
```
<div class=label>The `x86_64` assembly generated by [QBE][2] from the above IR for
`collatz.c`</div>

Assembly language can be
re-constructed from machine code binaries, a process called *disassembly*.

```c
> zig cc --target=x86_64-linux-musl -Os -c collatz.s
> objdum -da collatz.o
```
```sh
collatz.o:     file format elf64-x86-64
collatz.o

Disassembly of section .text:

0000000000000000 <collatz>:
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	89 f8                	mov    %edi,%eax
   6:	be 02 00 00 00       	mov    $0x2,%esi
   b:	89 c1                	mov    %eax,%ecx
   d:	99                   	cltd
   e:	f7 fe                	idiv   %esi
  10:	89 c8                	mov    %ecx,%eax
  12:	89 d1                	mov    %edx,%ecx
  14:	83 f9 00             	cmp    $0x0,%ecx
  17:	74 08                	je     21 <collatz+0x21>
  19:	6b c0 03             	imul   $0x3,%eax,%eax
  1c:	83 c0 01             	add    $0x1,%eax
  1f:	eb 08                	jmp    29 <collatz+0x29>
  21:	b9 02 00 00 00       	mov    $0x2,%ecx
  26:	99                   	cltd
  27:	f7 f9                	idiv   %ecx
  29:	c9                   	leave
  2a:	c3                   	ret
```
<div class=label>A disassembly of the generated `collatz.o` object file</div>

The binary generated by the basic compile process is usually an
organized collection of machine code called an *object file*. On Linux (and
most Unix-like systems) object files use the [ELF][10] file format.

Object files generally contain a *symbol table* section that stores
names and types for select pieces of machine code called *symbols*.
In C symbols are generated for all variables declared with
the `export` or `static` keyword, and all functions not declared with the
`static` keyword.

```c
> readelf -s collatz.o
```
```c
Symbol table '.symtab' contains 3 entries:
   Num:    Value          Size Type    Bind   Vis      Ndx Name
     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND 
     1: 0000000000000000     0 SECTION LOCAL  DEFAULT    1 .text
     2: 0000000000000000    43 FUNC    GLOBAL DEFAULT    1 collatz
```
<div class=label>The symbol table for `collatz.o`</div>

An *executable* is an object file with a designated place to
start program execution called an *entry point*.
In C it is common for text files to be separately
compiled into object files, then the object files are combined to form a single
executable.

```c
> cat print_collatz.c
```
```c
int printf(const char *fmt, ...);
int collatz(int n);

int main() {
    printf("collatz(5) = %d\n", collatz(5));
    return 0;
}
```
```c
> cproc-qbe print_collatz.c > print_collatz.ssa
> qbe -o print_collatz.s print_collatz.ssa
> zig cc --target=x86_64-linux-musl -Os -c print_collatz.s
> zig cc --target=x86_64-linux-musl -Os -o print_collatz print_collatz.o collatz.o
> ./print_collatz
collatz(5) = 16
```
<div class=label>Linking an executable from `print_collatz.o`, `collatz.o`, and [musl][4]'s libc and C runtime</div>

The process of combining object files together into a single binary
is called *static linking*[^1]. When statically linking an executable, most C compilers
automatically link object files for the C standard library and the C
runtime. It is the C runtime that defines an entry point and calls the
`main` function.

```c
> readelf -h print_collatz.o | grep "Entry point"
  Entry point address:               0x0
> readelf -h print_collatz | grep "Entry point"
  Entry point address:               0x1001eb0
```
<div class=label>Note that only the executable has a non-null entry point.</div>

Object files sometimes contain references to symbols that they do not define. For
example, our `print_collatz.o` file refers two undefined symbols: `collatz` and
`printf`. During linking the `collatz` symbol is defined in `collatz.o` and
`printf` is provided by libc.

```c
> readelf -s print_collatz.o
```
```c
Symbol table '.symtab' contains 6 entries:
   Num:    Value          Size Type    Bind   Vis      Ndx Name
     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND 
     1: 0000000000000000     0 SECTION LOCAL  DEFAULT    1 .text
     2: 0000000000000000     0 SECTION LOCAL  DEFAULT    3 .data
     3: 0000000000000000    40 FUNC    GLOBAL DEFAULT    1 main
     4: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND collatz
     5: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND printf
```

An executable created using only static linking is called a *static
executable*. The big strength of static executables
is that they are simple and self contained:
as long as two computers share the same CPU architecture and operating system,
a static executable can be copied from one machine to the other and
run without any setup.

Sometimes object files are combined into a single archive file or *static
library* in order to group related code for
convenient re-use.
For example, the [musl][4] implementation of the C standard library compiles into
a static library `libc.a` which can then be linked with every C application.

```c
> cat fibonacci.c
```
```c
int fibonacci(int n) {
    if (n <= 1) return 1;
    return fibonacci(n - 1) + fibonacci(n - 2);
}
```
```c
> zig cc --target=x86_64-linux-musl -c fibonacci.c
> zig ar -rs libfunmath.a collatz.o fibonacci.o
> cat print_funmath.c
```
```c
int printf(const char *fmt, ...);
int collatz(int n);
int fibonacci(int n);

int main() {
    printf("collatz(5)   = %d\n", collatz(5));
    printf("fibonacci(5) = %d\n", fibonacci(5));
    return 0;
}
```
```c
> zig cc --target=x86_64-linux-musl -c print_funmath.c
> zig cc --target=x86_64-linux-musl -o print_funmath print_funmath.o libfunmath.a
> ./print_funmath
collatz(5)   = 16
fibonacci(5) = 8
```
<div class=label>Creating a static library and linking it to an executable</div>

Usually there is a way for metadata to be passed along
between compilation stages in order to preserve information that would otherwise be
lost. E.g. debug builds store the file name and
line number where each piece of machine code originated.

```c
> zig cc --target=x86_64-linux-musl -g -o collatz_debug collatz.c print_collatz.c
> gdb collatz_debug
```
```c
(gdb) b main
(gdb) run
Breakpoint 1, main () at print_collatz.c:5
5     printf("collatz(5) = %d\n", collatz(5));
(gdb) step
collatz (n=5) at collatz.c:2
2     if (n % 2 == 0) {
(gdb) step
5     return 3 * n + 1;
(gdb) step
6   }
(gdb) step
collatz(5) = 16
main () at print_collatz.c:6
6     return 0;
(gdb) step
[Inferior 1 (process 367249) exited normally]
```
<div class=label>Generating a debug build of an executable and stepping through
it with [gdb][8]</div>

An alternative code re-use strategy to static linking is to combine object files
into a special binary
called *shared library* or *dynamic library*. Dynamic libraries are loaded into
memory separately and must be provided to the linked executable at runtime.
In contrast, when linking a static library the machine code is directly copied
into the resulting executable file.

There are two primary ways that
dynamic libraries are used: *dynamic linking* and *dynamic loading*.

```c
> zig cc --target=x86_64-linux-gnu --shared -o libfunmath.so fibonacci.c collatz.c
> zig cc --target=x86_64-linux-gnu -L. -lfunmath -o dprint_funmath print_funmath.c
> ./dprint_funmath
collatz(5)   = 16
fibonacci(5) = 8
```
<div class=label>Creating a shared library and linking it into a dynamic executable</div>

In dynamic linking a *dynamic executable* lists
a path to a binary called a dynamic linker and a path for each linked dynamic
library.
At runtime the dynamic linker will load each
required library into memory.

```c
> ldd dprint_funmath
```
```c
linux-vdso.so.1 (0x00007fff55392000)
./libfunmath.so (0x00007f138b1cb000)
libc.so.6 => /usr/lib/libc.so.6 (0x00007f138afd6000)
/lib64/ld-linux-x86-64.so.2 => /usr/lib64/ld-linux-x86-64.so.2 (0x00007f138b1d0000)
```
<div class=label>The linker is `ld-linux-x86-64.so.2` and the other paths are
libraries.</div>

One benefit of dynamic linking is memory savings: the dynamic linker can
have just one copy of each unique library loaded at a given time, shared between
all executables.
Another upside is patching: a dynamic library can be updated
without updating the executables that depend on it.

Instead of the linking a static musl `libc.a` into every binary, the
standard for [GNU libc][9] is to dynamiclly link a shared `libc.so`.

In dynamic loading an executable executes code during runtime to load a
dynamic library file into memory and lookup symbols. Dynamic loading is used for purposes
such as plugins and hot code swapping, i.e. updating an application's code while it is running.

```c
> cat hot_reload.c
```
```c
int open(const char *fname, int flags, int mode);
long read(int fd, char *buffer, long len);

int inotify_init(void);
int inotify_add_watch(int fd, const char *pname, int mask);

void *dlopen(const char *fname, int flags);
void *dlsym(void *restrict handle, const char *restrict symbol);
int dlclose(void *handle);

int printf(const char *fmt, ...);

int main() {
    void *lib_handle;
    int (*foo)(int);
    struct { int wd, mask, cookie, len; char name[128]; } event;

    int infd = inotify_init();
    inotify_add_watch(infd, "./lock", 0x200);

    while (1) {
        lib_handle = dlopen("./libfoo.so", 2);
        foo = dlsym(lib_handle, "foo");
        printf("foo(5) = %d\n", foo(5));
        read(infd, (char *)&event, sizeof(event));
        dlclose(lib_handle);
    }
}
```
```c
> zig cc --target=x86_64-linux-gnu -o hot_reload hot_reload.c
> mkdir lock
> echo "int foo(int n) { return 2 * n; }" > foo.c
> zig cc --target=x86_64-linux-gnu --shared -o libfoo.so foo.c
> ./hot_reload.c &
foo(5) = 10
> touch lock/foo
> echo "int foo(int n) { return 3 * n; }" > foo.c
> zig cc --target=x86_64-linux-gnu --shared -o libfoo.so foo.c
> rm lock/foo
foo(5) = 15
```
<div class=label>Watching and re-loading a dynamic library during runtime</div>

Note that in general dynamic loading is only supported for dynamic executables.

[^1]: The discussion in this article is a drastic simplification aiming for
    basic understanding, the linking process can be quite involved.

[1]: https://llvm.org/
[2]: https://c9x.me/compile/
[3]: https://ziglang.org/
[4]: https://musl.libc.org/
[5]: https://c9x.me/compile/
[6]: https://sr.ht/~mcf/cproc/
[7]: https://en.wikipedia.org/wiki/Collatz_conjecture
[8]: https://sourceware.org/gdb/
[9]: https://www.gnu.org/software/libc/
[10]: https://en.wikipedia.org/wiki/Executable_and_Linkable_Format

