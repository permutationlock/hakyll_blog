---
title: A fast overview of compiling binaries
author: A.
published: February 22, 2024
tags: asm, c, zig
---

Almost all compiled languages generate binary executables via the following
pipeline:

<div style="text-align: center">
```
text -> AST -> IR -> machine code
```
</div>

Here *text* refers to code written in the programming in question.
All examples in this article will use C.

```c
> cat collatz.c
```
```c
int collatz(int n) {
    if (n % 2 == 0) {
        return n / 2;
    }
    return 3 * n + 1;
}
```
<div class=label>A simple C file declaring a [Collatz][7] function</div>

An AST is an *abstract syntax* tree: a data structure representing the parsed
text code.

```c
> zig cc -E -Xclang -ast-dump collatz.c
```
```sh
`-FunctionDecl collatz 'int (int)'
  |-ParmVarDecl used n 'int'
  `-CompoundStmt
    |-IfStmt
    | |-BinaryOperator 'int' '=='
    | | |-BinaryOperator 'int' '%'
    | | | |-ImplicitCastExpr 'int' <LValueToRValue>
    | | | | `-DeclRefExpr 'int' lvalue ParmVar 'n' 'int'
    | | | `-IntegerLiteral 'int' 2
    | | `-IntegerLiteral 'int' 0
    | `-CompoundStmt
    |   `-ReturnStmt
    |     `-BinaryOperator 'int' '/'
    |       |-ImplicitCastExpr 'int' <LValueToRValue>
    |       | `-DeclRefExpr 'int' lvalue ParmVar 'n' 'int'
    |       `-IntegerLiteral 'int' 2
    `-ReturnStmt
      `-BinaryOperator 'int' '+'
        |-BinaryOperator 'int' '*'
        | |-IntegerLiteral 'int' 3
        | `-ImplicitCastExpr 'int' <LValueToRValue>
        |   `-DeclRefExpr 'int' lvalue ParmVar 'n' 'int'
        `-IntegerLiteral 'int' 1
```
<div class=label>A cleaned up AST from LLVM for our `collatz.c` file</div>

IR stands for *intermediate representation*: code designed to run on a basic abstract
machine. The IR step is mainly used to perform optimizations in a
simplified architecture agnostic environment.
Multiple IR stages might be involved in compilation, e.g. a compiler might have a
bespoke internal IR which is converted to second IR used by
a backend to generate machine code (such as [LLVM][1] or [QBE][2]).

```c
> cproc-qbe collatz.c
```
```ts
export function w $collatz(w %.1) {
@start.1
	%.2 =l alloc4 4
	storew %.1, %.2
@body.2
	%.3 =w loadw %.2
	%.4 =w rem %.3, 2
	%.5 =w ceqw %.4, 0
	jnz %.5, @if_true.3, @if_false.4
@if_true.3
	%.6 =w loadw %.2
	%.7 =w div %.6, 2
	ret %.7
@if_false.4
	%.8 =w loadw %.2
	%.9 =w mul 3, %.8
	%.10 =w add %.9, 1
	ret %.10
}
```
<div class=label>The [QBE][2] IR generated by [cproc][6] for `collatz.c`</div>

Finally, *machine code* is binary data and CPU instructions
that can be loaded into memory and run on a real (or virtual) CPU.
A human readable *assembly language* text version of the output from the
machine code step can be generated.

```c
> cproc-qbe collatz.c > collatz.ssa
> qbe collatz.ssa
```
```ts
.text
.globl collatz
collatz:
	pushq %rbp
	movq %rsp, %rbp
	movl %edi, %eax
	movl $2, %esi
	movl %eax, %ecx
	cltd
	idivl %esi
	movl %ecx, %eax
	movl %edx, %ecx
	cmpl $0, %ecx
	jz .Lbb3
	imull $3, %eax, %eax
	addl $1, %eax
	jmp .Lbb4
.Lbb3:
	movl $2, %ecx
	cltd
	idivl %ecx
.Lbb4:
	leave
	ret
.type collatz, @function
.size collatz, .-collatz
```
<div class=label>The `x86_64` assembly generated by [QBE][2] from the above IR for
`collatz.c`</div>

Assembly language text can also often be
re-constructed from machine code binaries, a process called *disassembly*.

```c
> qbe -o collatz.s collatz.ssa
> zig cc --target=x86_64-linux-musl -c collatz.s
> objdum -da collatz.o
```
```sh
collatz.o:     file format elf64-x86-64
collatz.o

Disassembly of section .text:

0000000000000000 <collatz>:
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	89 f8                	mov    %edi,%eax
   6:	be 02 00 00 00       	mov    $0x2,%esi
   b:	89 c1                	mov    %eax,%ecx
   d:	99                   	cltd
   e:	f7 fe                	idiv   %esi
  10:	89 c8                	mov    %ecx,%eax
  12:	89 d1                	mov    %edx,%ecx
  14:	83 f9 00             	cmp    $0x0,%ecx
  17:	74 08                	je     21 <collatz+0x21>
  19:	6b c0 03             	imul   $0x3,%eax,%eax
  1c:	83 c0 01             	add    $0x1,%eax
  1f:	eb 08                	jmp    29 <collatz+0x29>
  21:	b9 02 00 00 00       	mov    $0x2,%ecx
  26:	99                   	cltd
  27:	f7 f9                	idiv   %ecx
  29:	c9                   	leave
  2a:	c3                   	ret
```
<div class=label>A disassembly of the generated `collatz.o` object file</div>

The binary generated by the basic compiler process is usually an
organized collection of machine code called an *object file*.

```c
> hexdump collatz.o
```
```sh
0x0000040: 4855 e589 f889 02be 0000 8900 99c1 fef7
0x0000050: c889 d189 f983 7400 6b08 03c0 c083 eb01
0x0000060: b908 0002 0000 f799 c9f9 d1c3 0000 0400
```
<div class=label>The section of `collatz.o` with the machine code for our `collatz` function</div>

An *executable* is an object file that contains a designated place to
start execution called an *entry point*. 
In a language like C it is common for text files to be separately
compiled into object files, and then the object files are combined to form an
executable. The process of combining object files together into a single binary
is called *static linking*.

```c
> cat print_collatz.c
```
```c
int printf(const char *fmt, ...);
int collatz(int n);

int main() {
    printf("collatz(5) = %d\n", collatz(5));
    return 0;
}
```
```c
> cproc-qbe -o print_collatz.ssa print_collatz.c
> qbe -o print_collatz.s print_collatz.ssa
> zig cc --target=x86_64-linux-musl -c print_collatz.s
> zig cc --target=x86_64-linux-musl -o print_collatz print_collatz.o collatz.o
> ./print_collatz
collatz(5) = 16
```
<div class=label>An executable using our `collatz` object with musl
libc for `printf` and the runtime entry point</div>

Usually there is also a way for meta-information to be passed along
between stages in order to preserve information that would otherwise be
lost. E.g. a debug build might store the text file name and
line number where each symbol and CPU instruction in the output binary
originated from.

```c
> zig cc --target=x86_64-linux-musl -g -o collatz_debug collatz.c print_collatz.c
> gdb collatz_debug
```
```c
(gdb) b main
(gdb) run
Breakpoint 1, main () at print_collatz.c:5
5     printf("collatz(5) = %d\n", collatz(5));
(gdb) step
collatz (n=5) at collatz.c:2
2     if (n % 2 == 0) {
(gdb) step
5     return 3 * n + 1;
(gdb) step
6   }
(gdb) step
collatz(5) = 16
main () at print_collatz.c:6
6     return 0;
(gdb) step
[Inferior 1 (process 367249) exited normally]
```
<div class=label>Generating a debug build of our executable and stepping through
it with [gdb][8]</div>

Sometimes object files are combined into a single archive file or *static
library*, rather than an executable, to group related code for convenient re-use.
For example, the musl implementation of the C standard library compiles into
the static library `libc.a` which can then be linked with every C application
that uses libc[^1].

```c
> cat fibonacci.c
```
```c
int fibonacci(int n) {
    if (n <= 1) return 1;
    return fibonacci(n - 1) + fibonacci(n - 2);
}
```
```c
> zig cc --target=x86_64-linux-musl -c fibonacci.c
> zig ar -crs libfunmath.a collatz.o fibonacci.o
> cat print_funmath.c
```
```c
int printf(const char *fmt, ...);
int collatz(int n);
int fibonacci(int n);

int main() {
    printf("collatz(5)   = %d\n", collatz(5));
    printf("fibonacci(5) = %d\n", fibonacci(5));
    return 0;
}
```
```c
> zig cc --target=x86_64-linux-musl -o print_funmath print_funmath.c libfunmath.a
> ./print_funmath
collatz(5)   = 16
fibonacci(5) = 8
> ldd print_funmath
	not a dynamic executable
```
<div class=label>Creating a static library and linking it to an executable</div>

Another option for code re-use is to combine object files into a special binary
called a *shared library* or *dynamic library* that is designed to be loaded
into memory separately from the executables that make use of it. There are two
primary ways that
dynamic libraries are used: *dynamic loading* and *dynamic linking*.

In dynamic
loading an executable executes code during its runtime to load a
dynamic library file into memory. Dynamic loading is generally used for purposes
such as hot code swapping, e.g. updating a video game's code while it is running
during development.

```c
> cat hot_reload.c
```
```c
int open(const char *fname, int flags, int mode);
long read(int fd, char *buffer, long len);

int inotify_init(void);
int inotify_add_watch(int fd, const char *pname, int mask);

void *dlopen(const char *fname, int flags);
void *dlsym(void *restrict handle, const char *restrict symbol);
int dlclose(void *handle);

int printf(const char *fmt, ...);

int main() {
    void *lib_handle;
    int (*foo)(int);
    struct { int wd, mask, cookie, len; char name[128]; } event;

    int infd = inotify_init();
    inotify_add_watch(infd, "./lock", 0x200);

    while (1) {
        lib_handle = dlopen("./libfoo.so", 2);
        foo = dlsym(lib_handle, "foo");
        printf("foo(5) = %d\n", foo(5));
        read(infd, (char *)&event, sizeof(event));
        dlclose(lib_handle);
    }
}
```
```c
> zig cc --target=x86_64-linux-musl -o hot_reload hot_reload.c
> mkdir lock
> echo "int foo(int n) { return 2 * n; }" > foo.c
> zig cc --target=x86_64-linux-musl -shared -o libfoo.so foo.c
> ./hot_reload.c &
foo(5) = 10
> touch lock/foo
> echo "int foo(int n) { return 3 * n; }" > foo.c
> zig cc --target=x86_64-linux-musl -shared -o libfoo.so foo.c
> rm lock/fool
foo(5) = 15
```
<div class=label>Watching and re-loading a dynamic library during runtime</div>

In dynamic linking a *dynamic executable* lists in its binary format
the paths to the dynamic library files that it requres to run.
A system linker will then make sure that each
required library is loaded into memory and provided to the executable.

One benefit of dynamic linking is memory savings: the system linker can ensure
that only one copy of each library is loaded into memory and shared between
all applications that depend on it. Another upside is
patching: a dynamic library can be updated
without updating the executables that depend on it.
E.g. instead of the linking a static musl `libc.a` into every binary, the
standard for GNU libc is to make a dynamic `libc.so` that is
shared by all dynamic executables.

```c
> zig cc --target=x86_64-linux-gnu -shared -o libfunmath.so fibonacci.c collatz.c
> zig cc --target=x86_64-linux-gnu -L. -lfunmath -o dprint_funmath print_funmath.c
> ./dprint_funmath
collatz(5)   = 16
fibonacci(5) = 8
> ldd dprint_funmath
	linux-vdso.so.1 (...)
	./libfunmath.so (...)
	libc.so.6 => /usr/lib/libc.so.6 (...)
	/lib64/ld-linux-x86-64.so.2 => /usr/lib64/ld-linux-x86-64.so.2 (...)
```
<div class=label>Creating a shared library and linking it into a dynamic executable</div>

An executable that does not require dynamic linking is called a *static
executable*. The big strength of static executables
is that they are simple and self contained.
As long as two computers share the same CPU architecture and operating system,
a static executable can just be copied from one machine to the other and
run without any additional setup.

## Projects used in the above examples

 - the [Zig][3] programming language and C compiler toolchain
 - the amazing [musl libc][4] implementation
 - the [QBE compiler backend][5] and the [cproc][6] C11 to QBE IR compiler
 - the [GNU debugger][8]

## It's all a mess. The one out there. The one in here. The one that's coming...

This is the first of what I hope to be a series of articles on
building simple static software from scratch. The intention is to cover
programming in assembly, [QBE][2] IR, simple C without a preprocessor, and C11.

Along the way we'll
learn about the Linux system call ABI, the System-V ABI, debugging,
building a barebones Linux system with `busybox`,
ground up Linux software rendered graphics, distributing
graphical applications as Wayland clients, and cross-platform
Windows support with MinGW and Win32.


[^1]: In reality you also need to link one of the musl runtime object files
      `crt1.o` or
      `Scrt1.o` (and probably `crti.o` and `crtn.o` too) in order to have an
      entry point that sets up the environment and calls `main`. Unless the
      `-nostdlib` is specified, C compilers will automatically link libc and
      the C runtime.

[1]: https://llvm.org/
[2]: https://c9x.me/compile/
[3]: https://ziglang.org/
[4]: https://musl.libc.org/
[5]: https://c9x.me/compile/
[6]: https://sr.ht/~mcf/cproc/
[7]: https://en.wikipedia.org/wiki/Collatz_conjecture
[8]: https://sourceware.org/gdb/

